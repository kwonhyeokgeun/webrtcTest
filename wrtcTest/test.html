<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta http-equiv="X-UA-Compatible" content="IE=edge">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Document</title>
    <button id="disconnect_btn" >종료하기</button>
    <button id="share_start_btn" >화면공유 시작</button>
    <button id="share_stop_btn" >화면공유 중지</button>
    <div class="video-box">
        <div class="user-video-box">
            <video id="my_video"></video>

        </div>
        <div class="share-video-box">
            <!-- <video id="share_video"></video>-->
        </div>
    </div>

    <style>
        video {
            width: 150px; 
            height: 80px;
            padding: 30px;
        }
    </style>

</head>
<body>
    
    <script type="module">
        import { io } from "https://cdn.socket.io/4.4.1/socket.io.esm.min.js";
        
        const socket = io('https://localhost:443', {secure: true, cors: { origin: '*' }});
        

        const pc_config = {
            iceServers: [
                {
                    urls: "stun:edu.uxis.co.kr"
                },
                {
                    urls: "turn:edu.uxis.co.kr?transport=tcp",
                            "username": "webrtc",
                            "credential": "webrtc100!"
                }
            ]
        }


        let roomId, myName, numOfUsers=0; 
        let userNames={}; //userNames[socketId]="이름"
        let socketIds={}; //socketIds["이름"]=socketId

        let sendPC = {  //sendPC[purpose]=pc
            'user':{}, //카메라(유저 얼굴)
            'share':{}, //화면공유
        };
        let receivePCs = { //receivePCs[purpose][socketId]=pc
            'user':{},
            'share':{},
        };

        let shareUserName; //undefined
        

        window.addEventListener('unload', (ev) => { 
            userDisconnect();
        });

        function userDisconnect(){
            console.log("disconnect!!!")
            socket.emit("user_disconnect",{
                        roomId: roomId,
                        userName: myName,
                    });    
                    sendPC['user'].close();
            if(!sendPC['share'])
                sendPC['share'].close()
        }

        onload();
         

        function onload() {
            
            myName =  prompt("사용자 명");
            roomId = prompt("방 이름");

            document.querySelector("#disconnect_btn").onclick = userDisconnect
            document.querySelector("#share_start_btn").onclick = shareCheck
            document.querySelector("#share_stop_btn").onclick = shareStop

            socket.emit("meeting_room_info", {
                roomId: roomId,
            });
        }

        



        //기존 방의 유저수와 방장이름 얻어옴
        socket.on("meeting_room_info",data =>{
            console.log(data.numOfUsers ,"명이 이미 접속해있음")
            meetingStart()
        })

        //user가 들어오면 이미 들어와있던 user에게 수신되는 이벤트
        socket.on("user_enter", async (data) => {
            enterUserHandler(data);
        });

        //처음 방에 접속했을 때, 이미 방안에 들어와있던 user들의 정보를 받음
        socket.on("all_users", data =>{ 
            console.log("all_users : ",data.users)
            let users =data.users ;
            allUsersHandler(data)  //미리 접속한 유저들의 영상을 받기위한 pc, offer 생성

        })

        //클라이언트 입장에서 보내는 역할의 peerConnection 객체에서 수신한 answer 메시지(sender_offer의 응답받음)
        socket.on("get_sender_answer", (data) => {
            try {
                console.log("get_sender_answer 받음")
                sendPC[data.purpose].setRemoteDescription(new RTCSessionDescription(data.answer));
            } catch (error) {
                console.error(error);
            }
        });

        //클라이언트 입장에서 받는 역할의 peerConnection 객체에서 수신한 answer 메시지
        socket.on("get_receiver_answer", (data) => {
            try {
                let pc = receivePCs[data.purpose][data.id];
                if(pc.signalingState === 'stable') return; //?
                pc.setRemoteDescription(new RTCSessionDescription(data.answer));
            } catch (error) {
                console.error(error);
            }
        });

        //보내는 역할의 peerConnection 객체에서 수신한 candidate 메시지
        socket.on("get_sender_candidate", (data) => {
            try{
                let pc = sendPC[data.purpose];
                if(!data.candidate) return;
                if(!pc) return;
                pc.addIceCandidate(new RTCIceCandidate(data.candidate));
            } catch (error) {
                console.error(error);
            }
        });

        //받는 역할의 peerConnection 객체에서 수신한 candidate 메시지
        socket.on("get_receiver_candidate", (data) => {
            try {
                let pc = receivePCs[data.purpose][data.id];
                if(!data.candidate) return;
                if(!pc) return;
                pc.addIceCandidate(new RTCIceCandidate(data.candidate));
            } catch (error) {
                console.log(error);
            }
        });

        //같은 방에 있던 user가 나가면 그 방 안에있던 모든 user들에게 전송되는 이벤트
        socket.on("user_exit", (data) => {
            exitUserHandler(data);
        });

        
        //내 비디오에 내 영상 넣고 전송하기
        function meetingStart(){
            navigator.mediaDevices
                .getUserMedia({
                    audio: true,
                    video: true,
                })
                .then(async stream =>{
                    let myVideo = document.querySelector("#my_video");
                    myVideo.autoplay = true;
	                myVideo.playsinline = true;

                    //내 영상 비디오에 띄우기
                    let selfStream = new MediaStream();
                    selfStream.addTrack(stream.getVideoTracks()[0]);
                    myVideo.srcObject = selfStream;

                    //내 영상 전송용 pc와 offer생성
                    sendPC['user'] = createSenderPeerConnection(stream, 'user');
                    let offer = await createSenderOffer(sendPC['user']);

                    //방에 입장
                    socket.emit("meeting_join_room", {
                        roomId: roomId,
                        userName: myName,
                    });

                    //offer를 전송
                    await socket.emit("sender_offer", { 
                        offer,
                        roomId: roomId,
                        userName: myName,
                        purpose:'user'
                    });
                }).catch(error => {
                    console.error(error)
                })
        }

        //스트림 보내는 역할의 peerConnection 객체 생성
        function createSenderPeerConnection(stream, purpose, is_audio_true = 1) {
            let pc = new RTCPeerConnection(pc_config);
            
            pc.oniceconnectionstatechange = (e) => {
                //console.log(e);
            }

            pc.onicecandidate = (e) =>{
                if(e.candidate) {
                    socket.emit("sender_candidate", { 
                        candidate: e.candidate,
                        purpose: purpose,
                    });
                }
            }

            if(stream) {
                var videoTrack = stream.getVideoTracks()[0];
                var audioTrack = stream.getAudioTracks()[0];
                pc.addTrack(videoTrack, stream);
                //console.log("audio:",is_audio_true)
                if(is_audio_true !=0)  //나중에 수정하기
                    pc.addTrack(audioTrack, stream);
            } else {
                console.log("no localStream");
            }

            return pc;
        }

         //스트림 받는 역할의 peerConnection 객체 생성
         function createReceiverPeerConnection(senderSocketId, userName, purpose) {
            let pc = new RTCPeerConnection(pc_config);
            
            pc.oniceconnectionstatechange = (e) =>{
                //console.log(e);
            }

            pc.onicecandidate = (e) => {
                if(e.candidate) {
                    //수신 candidate 보냄
                    socket.emit("receiver_candidate", {  
                        candidate: e.candidate,
                        receiverSocketId: socket.id,
                        senderSocketId: senderSocketId,
                        purpose: purpose,
                        roomId : roomId,
                    });
                }
            }

            //스트림 보내는 쪽의 peerConnection에서 addTrack시 이벤트 발생
            var once = 1;
            pc.ontrack = (e) => {
                if(once == 1){
                    //stream을 video에 넣어주기
                    if(purpose=='user'){
                        meetingOntrackHandler(e.streams[0], userName, senderSocketId);
                    }else if(purpose=='share'){
                        shareOntrackHandler(e.streams[0], userName, senderSocketId);
                    }
                    //console.log('한번만 나오는지')
                }
                once+=1;
            }

            return pc;
        }

        //보내는 역할의 peerConnection 객체에서 offer 전송 (통신 시작)
        async function createSenderOffer(pc){
            try {
                let offer = await pc.createOffer({ //보내기 위함으로 false임..?
                    offerToReceiveAudio: false,
                    offerToReceiveVideo: false,
                });
                await pc.setLocalDescription(new RTCSessionDescription(offer));
                
                console.log("send offer:",offer);

                return offer;
            } catch(error) {
                console.log(error);
            }
        }

        //받는 역할의 peerConnection 객체에서 offer 전송 (통신 시작)
        async function createReceiverOffer(pc) {
            try {
                let offer = await pc.createOffer({
                    offerToReceiveAudio: true,
                    offerToReceiveVideo: true,
                });
                await pc.setLocalDescription(new RTCSessionDescription(offer));
                    
                return offer;
            } catch (error) {
                console.error(error);
            }
        }

        //기존 모든 유저들 영상을 받기위한 pc와 offer생성
        async function allUsersHandler(data) {   //자신을 제외한 모든 유저의 receiverPc생성, 비디오 생성(처음 접속했을 때 한번만)
            try {
                let len = data.users.length;

                for(let i=0; i<len; i++) {
                    var socketId = data.users[i].socketId;
                    var userName = data.users[i].userName;
                    var stream = data.users[i].stream;

                    makeUserVideo(socketId, userName);

                    userNames[socketId]=userName;
                    socketIds[userName]=socketId;

                    /*
                    if(stream ===null){ //noCam인 경우
                        usersName[socketId]=userName;
                        meetingOntrackHandler(null, userName, socketId) //아직안함
                    }
                    else{*/

                    //기존 유저들 영상을 받을 pc와 offer를 생성
                    let pc = createReceiverPeerConnection(socketId, userName, 'user');
                    let offer = await createReceiverOffer(pc);
                    setTimeout(500);  //??

                    receivePCs['user'][socketId] = pc;
                    numOfUsers=data.users.length+1;
                    

                    //수신 offer 보냄
                    await socket.emit("receiver_offer", {
                        offer,
                        receiverSocketId: socket.id,
                        senderSocketId: socketId,
                        purpose: 'user',
                        roomId: roomId
                    });	
                    
                }
            } catch(err) {
                console.error(err);
            }
        }

        async function enterUserHandler(data) {   //누군가 들어왔을 때
            try {
                makeUserVideo(data.socketId, data.userName);

                let pc = createReceiverPeerConnection(data.socketId, data.userName, 'user');
                let offer = await createReceiverOffer(pc);

                userNames[data.socketId]=data.userName;
                socketIds[data.userName]=data.socketId;
                receivePCs['user'][data.socketId] = pc;
                numOfUsers++;

                await socket.emit("receiver_offer", {
                    offer,
                    receiverSocketId: socket.id,
                    senderSocketId: data.socketId,
                    purpose: 'user',
                    roomId:roomId,
                });

                
            } catch (error) {
                console.error(error);
            }
            
        }

       

        //유저별 stream을 video에 넣어줌(화면에 영상 띄움)
        function meetingOntrackHandler(stream, userName, senderSocketId) {
            console.log(userName,"meeting OntrackHandler 실행")
            //userStream[senderSocketId]=stream;
            let videoId = userName + "_video"
            let video = document.querySelector(`#${videoId}`);
            video.srcObject = stream;
        }

        //새로운 유저 비디오 생성
        function makeUserVideo(socketId, userName){
            let box = document.querySelector(".user-video-box");
            let newVideo = document.createElement("video");
            newVideo.autoplay = true;
            newVideo.playsinline = true; //?
            newVideo.id = userName + "_video";
            box.appendChild(newVideo)
        }

        //나간 유저 video삭제
        function deleteUserVideo(socketId, userName){
            let video = document.querySelector(`#${userName}_video`);
            video.remove();
        }

        

        //나간 유저의 정보 지우고 비디오 지우기
        function exitUserHandler(data){
            let socketId = data.socketId;
            let userName = data.userName;

            numOfUsers--;
            try{
                delete userNames[socketId];
                delete socketIds[userName];
                
                if(!receivePCs['user'][socketId]) {
                    receivePCs['user'][socketId].close();
                    delete receivePCs['user'][socketId];
                }

                deleteUserVideo(socketId, userName)

            }catch(e){
                console.error(e);
            }
        }


        //==============================================================================

        //화면 공유 가능하다는 이벤트
        socket.on("share_ok", (data) => {
            console.log("화면 공유 가능")
            shareStart();

        });

        //다른 유저가 화면공유를 시작함
        socket.on("share_request", (data) => {
            shareRequestHandler(data);
        });

        //다른 유저가 화면공유 중지함
        socket.on("share_disconnect", (data) => {
            let socketId=data.id;
            shareUserName=undefined;

            receivePCs['share'][socketId].close();
            delete receivePCs['share'][socketId];
            deleteShareVideo();
        });

        //화면공유 가능여부 체크
        function shareCheck(){
            if(shareUserName !== undefined) return;
            socket.emit('share_check', {roomId}); 
        }

        

        //화면 공유용 비디오 생성
        function makeShareVideo(){
            let box = document.querySelector(".user-video-box");
            let shareVideo = document.createElement("video");
            shareVideo.autoplay = true;
            shareVideo.playsinline = true; //?
            shareVideo.id = "share_video";
            box.appendChild(shareVideo)
        }

        //화면공유 비디오 삭제
        function deleteShareVideo(){
            let shareVideo = document.querySelector("#share_video");
            shareVideo.remove();
        }
        

        //내가 화면 공유 시작
        function shareStart(){
            
            navigator.mediaDevices.getDisplayMedia({
                audio:true,
                video:true
            }).then(async function(stream){ 
                console.log("stream check:",stream.getAudioTracks().length);//1이면 audio(o) 0이면 audio(x)
                var is_audio_true = stream.getAudioTracks().length
                shareUserName = myName;

                //내 화면공유 볼 비디오 생성
                makeShareVideo();  

                //내 화면 공유 stream 비디오에 넣기 
                let selfShareStream = new MediaStream();
                selfShareStream.addTrack(stream.getVideoTracks()[0]);
                document.querySelector("#share_video").srcObject = selfShareStream;

                sendPC['share'] = createSenderPeerConnection(stream, 'share',is_audio_true);
                let offer = await createSenderOffer(sendPC['share']);

                await socket.emit('sender_offer', {
                    offer,
                    roomId: roomId,
                    userName: myName,
                    purpose: 'share',
                });

            }).catch(error => {
                    console.log('error display stream',error);
            });
        }

        //나의 화면 공유 중지
        function shareStop(){
            console.log("shareStop", shareUserName)
            if(shareUserName !== myName) return;
            shareUserName=undefined;
            
            deleteShareVideo();
        
            sendPC['share']={};
            socket.emit('share_disconnect',{roomId});
        }

        //다른사람의 화면공유 받는 요청 처리
        async function shareRequestHandler(data) { 
            makeShareVideo();

            receivePCs['share'][data.socketId] = createReceiverPeerConnection(data.socketId, data.userName, 'share');
            let offer = await createReceiverOffer(receivePCs['share'][data.socketId]);

            shareUserName = data.userName;

            await socket.emit('receiver_offer', {
                offer,
                receiverSocketId: socket.id,
                senderSocketId: data.socketId,
                purpose: 'share',
                roomId,
            });
        }

        //화면 공유 stream을 video에 넣음
        function shareOntrackHandler(stream, userName, senderSocketId) {
            //stream['share'][senderSocketId]=stream;
            let video = document.querySelector("#share_video");
            video.srcObject = stream;
        }
        
    </script>
</body>
</html>